// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: subscriptions.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSubscriptions = `-- name: GetSubscriptions :many
SELECT id, source, status, status_formatted, created_at, updated_at, renews_at, trial_ends_at, ends_at, user_id, lemonsqueezy_subscription_id, lemonsqueezy_customer_id, lemonsqueezy_order_id, lemonsqueezy_product_id, lemonsqueezy_variant_id FROM subscriptions WHERE user_id = $1
`

func (q *Queries) GetSubscriptions(ctx context.Context, userID string) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.Status,
			&i.StatusFormatted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RenewsAt,
			&i.TrialEndsAt,
			&i.EndsAt,
			&i.UserID,
			&i.LemonsqueezySubscriptionID,
			&i.LemonsqueezyCustomerID,
			&i.LemonsqueezyOrderID,
			&i.LemonsqueezyProductID,
			&i.LemonsqueezyVariantID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLemonSqueezySubscription = `-- name: UpsertLemonSqueezySubscription :one
INSERT INTO subscriptions (
    id,
    source,
    status,
    status_formatted,
    renews_at,
    trial_ends_at,
    ends_at,
    created_at,
    updated_at,
    user_id,
    lemonsqueezy_subscription_id,
    lemonsqueezy_customer_id,
    lemonsqueezy_order_id,
    lemonsqueezy_product_id,
    lemonsqueezy_variant_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
ON CONFLICT (lemonsqueezy_subscription_id) DO UPDATE SET 
    status = EXCLUDED.status,
    status_formatted = EXCLUDED.status_formatted,
    renews_at = EXCLUDED.renews_at,
    trial_ends_at = EXCLUDED.trial_ends_at,
    ends_at = EXCLUDED.ends_at,
    updated_at = EXCLUDED.updated_at,
    lemonsqueezy_customer_id = EXCLUDED.lemonsqueezy_customer_id,
    lemonsqueezy_order_id = EXCLUDED.lemonsqueezy_order_id,
    lemonsqueezy_product_id = EXCLUDED.lemonsqueezy_product_id,
    lemonsqueezy_variant_id = EXCLUDED.lemonsqueezy_variant_id
RETURNING id, source, status, status_formatted, created_at, updated_at, renews_at, trial_ends_at, ends_at, user_id, lemonsqueezy_subscription_id, lemonsqueezy_customer_id, lemonsqueezy_order_id, lemonsqueezy_product_id, lemonsqueezy_variant_id
`

type UpsertLemonSqueezySubscriptionParams struct {
	ID                         string
	Source                     string
	Status                     string
	StatusFormatted            string
	RenewsAt                   pgtype.Timestamp
	TrialEndsAt                pgtype.Timestamp
	EndsAt                     pgtype.Timestamp
	CreatedAt                  pgtype.Timestamp
	UpdatedAt                  pgtype.Timestamp
	UserID                     string
	LemonsqueezySubscriptionID pgtype.Text
	LemonsqueezyCustomerID     pgtype.Text
	LemonsqueezyOrderID        pgtype.Text
	LemonsqueezyProductID      pgtype.Text
	LemonsqueezyVariantID      pgtype.Text
}

func (q *Queries) UpsertLemonSqueezySubscription(ctx context.Context, arg UpsertLemonSqueezySubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, upsertLemonSqueezySubscription,
		arg.ID,
		arg.Source,
		arg.Status,
		arg.StatusFormatted,
		arg.RenewsAt,
		arg.TrialEndsAt,
		arg.EndsAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UserID,
		arg.LemonsqueezySubscriptionID,
		arg.LemonsqueezyCustomerID,
		arg.LemonsqueezyOrderID,
		arg.LemonsqueezyProductID,
		arg.LemonsqueezyVariantID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.Status,
		&i.StatusFormatted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RenewsAt,
		&i.TrialEndsAt,
		&i.EndsAt,
		&i.UserID,
		&i.LemonsqueezySubscriptionID,
		&i.LemonsqueezyCustomerID,
		&i.LemonsqueezyOrderID,
		&i.LemonsqueezyProductID,
		&i.LemonsqueezyVariantID,
	)
	return i, err
}
