// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: app_entitlements.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAppEntitlements = `-- name: GetAppEntitlements :many
SELECT id, app_id, user_id, source, source_id, name, description, feature_monthly_execution_time_limit, feature_monthly_execution_time_additive, created_at, updated_at, valid_from, valid_until FROM app_entitlements 
WHERE 
    app_id = $1 AND
    (valid_from IS NULL OR valid_from <= $2) AND 
    (valid_until IS NULL OR valid_until >= $2)
`

type GetAppEntitlementsParams struct {
	AppID   string
	ValidAt pgtype.Timestamp
}

func (q *Queries) GetAppEntitlements(ctx context.Context, arg GetAppEntitlementsParams) ([]AppEntitlement, error) {
	rows, err := q.db.Query(ctx, getAppEntitlements, arg.AppID, arg.ValidAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEntitlement
	for rows.Next() {
		var i AppEntitlement
		if err := rows.Scan(
			&i.ID,
			&i.AppID,
			&i.UserID,
			&i.Source,
			&i.SourceID,
			&i.Name,
			&i.Description,
			&i.FeatureMonthlyExecutionTimeLimit,
			&i.FeatureMonthlyExecutionTimeAdditive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResolvedAppEntitlement = `-- name: GetResolvedAppEntitlement :one
SELECT app_id, feature_monthly_execution_time_limit FROM app_entitlements_resolved_view WHERE app_id = $1
`

func (q *Queries) GetResolvedAppEntitlement(ctx context.Context, appID string) (AppEntitlementsResolvedView, error) {
	row := q.db.QueryRow(ctx, getResolvedAppEntitlement, appID)
	var i AppEntitlementsResolvedView
	err := row.Scan(&i.AppID, &i.FeatureMonthlyExecutionTimeLimit)
	return i, err
}

const upsertAppEntitlement = `-- name: UpsertAppEntitlement :one
INSERT INTO app_entitlements (
    id,
    app_id,
    user_id,
    source,
    source_id,
    name,
    description,
    feature_monthly_execution_time_limit,
    feature_monthly_execution_time_additive,
    created_at,
    updated_at,
    valid_from,
    valid_until
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
) ON CONFLICT (app_id, source, source_id) DO UPDATE SET 
    feature_monthly_execution_time_limit = EXCLUDED.feature_monthly_execution_time_limit,
    feature_monthly_execution_time_additive = EXCLUDED.feature_monthly_execution_time_additive,
    updated_at = EXCLUDED.updated_at,
    valid_from = EXCLUDED.valid_from,
    valid_until = EXCLUDED.valid_until
RETURNING id, app_id, user_id, source, source_id, name, description, feature_monthly_execution_time_limit, feature_monthly_execution_time_additive, created_at, updated_at, valid_from, valid_until
`

type UpsertAppEntitlementParams struct {
	ID                                  string
	AppID                               string
	UserID                              pgtype.Text
	Source                              string
	SourceID                            pgtype.Text
	Name                                pgtype.Text
	Description                         pgtype.Text
	FeatureMonthlyExecutionTimeLimit    int32
	FeatureMonthlyExecutionTimeAdditive bool
	CreatedAt                           pgtype.Timestamp
	UpdatedAt                           pgtype.Timestamp
	ValidFrom                           pgtype.Timestamp
	ValidUntil                          pgtype.Timestamp
}

func (q *Queries) UpsertAppEntitlement(ctx context.Context, arg UpsertAppEntitlementParams) (AppEntitlement, error) {
	row := q.db.QueryRow(ctx, upsertAppEntitlement,
		arg.ID,
		arg.AppID,
		arg.UserID,
		arg.Source,
		arg.SourceID,
		arg.Name,
		arg.Description,
		arg.FeatureMonthlyExecutionTimeLimit,
		arg.FeatureMonthlyExecutionTimeAdditive,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i AppEntitlement
	err := row.Scan(
		&i.ID,
		&i.AppID,
		&i.UserID,
		&i.Source,
		&i.SourceID,
		&i.Name,
		&i.Description,
		&i.FeatureMonthlyExecutionTimeLimit,
		&i.FeatureMonthlyExecutionTimeAdditive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidUntil,
	)
	return i, err
}
