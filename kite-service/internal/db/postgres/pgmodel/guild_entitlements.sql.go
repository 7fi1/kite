// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: guild_entitlements.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getGuildEntitlements = `-- name: GetGuildEntitlements :many
SELECT id, guild_id, user_id, source, source_id, name, description, feature_monthly_execution_time_limit, feature_monthly_execution_time_additive, created_at, updated_at, valid_from, valid_until FROM guild_entitlements 
WHERE 
    guild_id = $1 AND
    (valid_from IS NULL OR valid_from <= $2) AND 
    (valid_until IS NULL OR valid_until >= $2)
`

type GetGuildEntitlementsParams struct {
	GuildID string
	ValidAt pgtype.Timestamp
}

func (q *Queries) GetGuildEntitlements(ctx context.Context, arg GetGuildEntitlementsParams) ([]GuildEntitlement, error) {
	rows, err := q.db.Query(ctx, getGuildEntitlements, arg.GuildID, arg.ValidAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GuildEntitlement
	for rows.Next() {
		var i GuildEntitlement
		if err := rows.Scan(
			&i.ID,
			&i.GuildID,
			&i.UserID,
			&i.Source,
			&i.SourceID,
			&i.Name,
			&i.Description,
			&i.FeatureMonthlyExecutionTimeLimit,
			&i.FeatureMonthlyExecutionTimeAdditive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResolvedGuildEntitlement = `-- name: GetResolvedGuildEntitlement :one
SELECT guild_id, feature_monthly_execution_time_limit FROM guild_entitlements_resolved_view WHERE guild_id = $1
`

func (q *Queries) GetResolvedGuildEntitlement(ctx context.Context, guildID string) (GuildEntitlementsResolvedView, error) {
	row := q.db.QueryRow(ctx, getResolvedGuildEntitlement, guildID)
	var i GuildEntitlementsResolvedView
	err := row.Scan(&i.GuildID, &i.FeatureMonthlyExecutionTimeLimit)
	return i, err
}

const upsertGuildEntitlement = `-- name: UpsertGuildEntitlement :one
INSERT INTO guild_entitlements (
    id,
    guild_id,
    user_id,
    source,
    source_id,
    name,
    description,
    feature_monthly_execution_time_limit,
    feature_monthly_execution_time_additive,
    created_at,
    updated_at,
    valid_from,
    valid_until
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
) ON CONFLICT (guild_id, source, source_id) DO UPDATE SET 
    feature_monthly_execution_time_limit = EXCLUDED.feature_monthly_execution_time_limit,
    feature_monthly_execution_time_additive = EXCLUDED.feature_monthly_execution_time_additive,
    updated_at = EXCLUDED.updated_at,
    valid_from = EXCLUDED.valid_from,
    valid_until = EXCLUDED.valid_until
RETURNING id, guild_id, user_id, source, source_id, name, description, feature_monthly_execution_time_limit, feature_monthly_execution_time_additive, created_at, updated_at, valid_from, valid_until
`

type UpsertGuildEntitlementParams struct {
	ID                                  string
	GuildID                             string
	UserID                              pgtype.Text
	Source                              string
	SourceID                            pgtype.Text
	Name                                pgtype.Text
	Description                         pgtype.Text
	FeatureMonthlyExecutionTimeLimit    int32
	FeatureMonthlyExecutionTimeAdditive bool
	CreatedAt                           pgtype.Timestamp
	UpdatedAt                           pgtype.Timestamp
	ValidFrom                           pgtype.Timestamp
	ValidUntil                          pgtype.Timestamp
}

func (q *Queries) UpsertGuildEntitlement(ctx context.Context, arg UpsertGuildEntitlementParams) (GuildEntitlement, error) {
	row := q.db.QueryRow(ctx, upsertGuildEntitlement,
		arg.ID,
		arg.GuildID,
		arg.UserID,
		arg.Source,
		arg.SourceID,
		arg.Name,
		arg.Description,
		arg.FeatureMonthlyExecutionTimeLimit,
		arg.FeatureMonthlyExecutionTimeAdditive,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i GuildEntitlement
	err := row.Scan(
		&i.ID,
		&i.GuildID,
		&i.UserID,
		&i.Source,
		&i.SourceID,
		&i.Name,
		&i.Description,
		&i.FeatureMonthlyExecutionTimeLimit,
		&i.FeatureMonthlyExecutionTimeAdditive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidUntil,
	)
	return i, err
}
