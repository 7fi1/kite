// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: apps.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserIsOwnerOfApp = `-- name: CheckUserIsOwnerOfApp :one
SELECT true FROM apps WHERE id = $1 AND owner_user_id = $2
`

type CheckUserIsOwnerOfAppParams struct {
	ID          string
	OwnerUserID string
}

func (q *Queries) CheckUserIsOwnerOfApp(ctx context.Context, arg CheckUserIsOwnerOfAppParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserIsOwnerOfApp, arg.ID, arg.OwnerUserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createApp = `-- name: CreateApp :exec
INSERT INTO apps (
    id,
    owner_user_id,
    token,
    token_invalid,
    public_key,
    user_id,
    user_name,
    user_discriminator,
    user_avatar,
    user_banner,
    user_bio,
    status_type,
    status_activity_type,
    status_activity_name,
    status_activity_state,
    status_activity_url,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18
)
`

type CreateAppParams struct {
	ID                  string
	OwnerUserID         string
	Token               string
	TokenInvalid        bool
	PublicKey           string
	UserID              string
	UserName            string
	UserDiscriminator   string
	UserAvatar          pgtype.Text
	UserBanner          pgtype.Text
	UserBio             pgtype.Text
	StatusType          string
	StatusActivityType  pgtype.Int4
	StatusActivityName  pgtype.Text
	StatusActivityState pgtype.Text
	StatusActivityUrl   pgtype.Text
	CreatedAt           pgtype.Timestamp
	UpdatedAt           pgtype.Timestamp
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) error {
	_, err := q.db.Exec(ctx, createApp,
		arg.ID,
		arg.OwnerUserID,
		arg.Token,
		arg.TokenInvalid,
		arg.PublicKey,
		arg.UserID,
		arg.UserName,
		arg.UserDiscriminator,
		arg.UserAvatar,
		arg.UserBanner,
		arg.UserBio,
		arg.StatusType,
		arg.StatusActivityType,
		arg.StatusActivityName,
		arg.StatusActivityState,
		arg.StatusActivityUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteApp = `-- name: DeleteApp :exec
DELETE FROM apps WHERE id = $1
`

func (q *Queries) DeleteApp(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteApp, id)
	return err
}

const getApp = `-- name: GetApp :one
SELECT id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at FROM apps WHERE id = $1
`

func (q *Queries) GetApp(ctx context.Context, id string) (App, error) {
	row := q.db.QueryRow(ctx, getApp, id)
	var i App
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Token,
		&i.TokenInvalid,
		&i.PublicKey,
		&i.UserID,
		&i.UserName,
		&i.UserDiscriminator,
		&i.UserAvatar,
		&i.UserBanner,
		&i.UserBio,
		&i.StatusType,
		&i.StatusActivityType,
		&i.StatusActivityName,
		&i.StatusActivityState,
		&i.StatusActivityUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppForOwnerUser = `-- name: GetAppForOwnerUser :one
SELECT id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at FROM apps WHERE id = $1 AND owner_user_id = $2
`

type GetAppForOwnerUserParams struct {
	ID          string
	OwnerUserID string
}

func (q *Queries) GetAppForOwnerUser(ctx context.Context, arg GetAppForOwnerUserParams) (App, error) {
	row := q.db.QueryRow(ctx, getAppForOwnerUser, arg.ID, arg.OwnerUserID)
	var i App
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Token,
		&i.TokenInvalid,
		&i.PublicKey,
		&i.UserID,
		&i.UserName,
		&i.UserDiscriminator,
		&i.UserAvatar,
		&i.UserBanner,
		&i.UserBio,
		&i.StatusType,
		&i.StatusActivityType,
		&i.StatusActivityName,
		&i.StatusActivityState,
		&i.StatusActivityUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppsForOwnerUser = `-- name: GetAppsForOwnerUser :many
SELECT id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at FROM apps WHERE owner_user_id = $1
`

func (q *Queries) GetAppsForOwnerUser(ctx context.Context, ownerUserID string) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsForOwnerUser, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Token,
			&i.TokenInvalid,
			&i.PublicKey,
			&i.UserID,
			&i.UserName,
			&i.UserDiscriminator,
			&i.UserAvatar,
			&i.UserBanner,
			&i.UserBio,
			&i.StatusType,
			&i.StatusActivityType,
			&i.StatusActivityName,
			&i.StatusActivityState,
			&i.StatusActivityUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppsWithValidToken = `-- name: GetAppsWithValidToken :many
SELECT id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at FROM apps WHERE token_invalid = false
`

func (q *Queries) GetAppsWithValidToken(ctx context.Context) ([]App, error) {
	rows, err := q.db.Query(ctx, getAppsWithValidToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Token,
			&i.TokenInvalid,
			&i.PublicKey,
			&i.UserID,
			&i.UserName,
			&i.UserDiscriminator,
			&i.UserAvatar,
			&i.UserBanner,
			&i.UserBio,
			&i.StatusType,
			&i.StatusActivityType,
			&i.StatusActivityName,
			&i.StatusActivityState,
			&i.StatusActivityUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctAppIDs = `-- name: GetDistinctAppIDs :many
SELECT DISTINCT id FROM apps
`

func (q *Queries) GetDistinctAppIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctAppIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAppTokenInvalid = `-- name: SetAppTokenInvalid :exec
UPDATE apps SET token_invalid = true WHERE id = $1
`

func (q *Queries) SetAppTokenInvalid(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, setAppTokenInvalid, id)
	return err
}

const updateApp = `-- name: UpdateApp :one
UPDATE apps SET 
    token = $2, 
    token_invalid = false,
    public_key = $3,
    user_id = $4,
    user_name = $5,
    user_discriminator = $6,
    user_avatar = $7,
    user_banner = $8,
    user_bio = $9,
    updated_at = $10
WHERE id = $1 
RETURNING id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at
`

type UpdateAppParams struct {
	ID                string
	Token             string
	PublicKey         string
	UserID            string
	UserName          string
	UserDiscriminator string
	UserAvatar        pgtype.Text
	UserBanner        pgtype.Text
	UserBio           pgtype.Text
	UpdatedAt         pgtype.Timestamp
}

func (q *Queries) UpdateApp(ctx context.Context, arg UpdateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, updateApp,
		arg.ID,
		arg.Token,
		arg.PublicKey,
		arg.UserID,
		arg.UserName,
		arg.UserDiscriminator,
		arg.UserAvatar,
		arg.UserBanner,
		arg.UserBio,
		arg.UpdatedAt,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Token,
		&i.TokenInvalid,
		&i.PublicKey,
		&i.UserID,
		&i.UserName,
		&i.UserDiscriminator,
		&i.UserAvatar,
		&i.UserBanner,
		&i.UserBio,
		&i.StatusType,
		&i.StatusActivityType,
		&i.StatusActivityName,
		&i.StatusActivityState,
		&i.StatusActivityUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAppStatus = `-- name: UpdateAppStatus :one
UPDATE apps SET 
    status_type = $2, 
    status_activity_type = $3, 
    status_activity_name = $4, 
    status_activity_state = $5, 
    status_activity_url = $6,
    updated_at = $7
WHERE id = $1 
RETURNING id, owner_user_id, token, token_invalid, public_key, user_id, user_name, user_discriminator, user_avatar, user_banner, user_bio, status_type, status_activity_type, status_activity_name, status_activity_state, status_activity_url, created_at, updated_at
`

type UpdateAppStatusParams struct {
	ID                  string
	StatusType          string
	StatusActivityType  pgtype.Int4
	StatusActivityName  pgtype.Text
	StatusActivityState pgtype.Text
	StatusActivityUrl   pgtype.Text
	UpdatedAt           pgtype.Timestamp
}

func (q *Queries) UpdateAppStatus(ctx context.Context, arg UpdateAppStatusParams) (App, error) {
	row := q.db.QueryRow(ctx, updateAppStatus,
		arg.ID,
		arg.StatusType,
		arg.StatusActivityType,
		arg.StatusActivityName,
		arg.StatusActivityState,
		arg.StatusActivityUrl,
		arg.UpdatedAt,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Token,
		&i.TokenInvalid,
		&i.PublicKey,
		&i.UserID,
		&i.UserName,
		&i.UserDiscriminator,
		&i.UserAvatar,
		&i.UserBanner,
		&i.UserBio,
		&i.StatusType,
		&i.StatusActivityType,
		&i.StatusActivityName,
		&i.StatusActivityState,
		&i.StatusActivityUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
