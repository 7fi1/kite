// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: plugins.sql

package pgmodel

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deletePluginInstance = `-- name: DeletePluginInstance :exec
DELETE FROM plugin_instances WHERE app_id = $1 AND plugin_id = $2
`

type DeletePluginInstanceParams struct {
	AppID    string
	PluginID string
}

func (q *Queries) DeletePluginInstance(ctx context.Context, arg DeletePluginInstanceParams) error {
	_, err := q.db.Exec(ctx, deletePluginInstance, arg.AppID, arg.PluginID)
	return err
}

const getEnabledPluginInstancesUpdatedSince = `-- name: GetEnabledPluginInstancesUpdatedSince :many
SELECT plugin_id, app_id, enabled, config, created_at, updated_at, commands_deployed_at FROM plugin_instances WHERE enabled = TRUE AND updated_at > $1
`

func (q *Queries) GetEnabledPluginInstancesUpdatedSince(ctx context.Context, updatedAt pgtype.Timestamp) ([]PluginInstance, error) {
	rows, err := q.db.Query(ctx, getEnabledPluginInstancesUpdatedSince, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PluginInstance
	for rows.Next() {
		var i PluginInstance
		if err := rows.Scan(
			&i.PluginID,
			&i.AppID,
			&i.Enabled,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommandsDeployedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartialEnabledPluginInstanceIDs = `-- name: GetPartialEnabledPluginInstanceIDs :many
SELECT app_id, plugin_id FROM plugin_instances WHERE enabled = TRUE
`

type GetPartialEnabledPluginInstanceIDsRow struct {
	AppID    string
	PluginID string
}

func (q *Queries) GetPartialEnabledPluginInstanceIDs(ctx context.Context) ([]GetPartialEnabledPluginInstanceIDsRow, error) {
	rows, err := q.db.Query(ctx, getPartialEnabledPluginInstanceIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartialEnabledPluginInstanceIDsRow
	for rows.Next() {
		var i GetPartialEnabledPluginInstanceIDsRow
		if err := rows.Scan(&i.AppID, &i.PluginID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPluginInstance = `-- name: GetPluginInstance :one
SELECT plugin_id, app_id, enabled, config, created_at, updated_at, commands_deployed_at FROM plugin_instances WHERE app_id = $1 AND plugin_id = $2
`

type GetPluginInstanceParams struct {
	AppID    string
	PluginID string
}

func (q *Queries) GetPluginInstance(ctx context.Context, arg GetPluginInstanceParams) (PluginInstance, error) {
	row := q.db.QueryRow(ctx, getPluginInstance, arg.AppID, arg.PluginID)
	var i PluginInstance
	err := row.Scan(
		&i.PluginID,
		&i.AppID,
		&i.Enabled,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommandsDeployedAt,
	)
	return i, err
}

const updatePluginInstancesCommandsDeployedAt = `-- name: UpdatePluginInstancesCommandsDeployedAt :exec
UPDATE plugin_instances SET commands_deployed_at = $2 WHERE app_id = $1
`

type UpdatePluginInstancesCommandsDeployedAtParams struct {
	AppID              string
	CommandsDeployedAt pgtype.Timestamp
}

func (q *Queries) UpdatePluginInstancesCommandsDeployedAt(ctx context.Context, arg UpdatePluginInstancesCommandsDeployedAtParams) error {
	_, err := q.db.Exec(ctx, updatePluginInstancesCommandsDeployedAt, arg.AppID, arg.CommandsDeployedAt)
	return err
}

const upsertPluginInstance = `-- name: UpsertPluginInstance :one
INSERT INTO plugin_instances (
    app_id, 
    plugin_id, 
    enabled, 
    config, 
    created_at, 
    updated_at
) VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5, 
    $6
) ON CONFLICT (app_id, plugin_id) 
DO UPDATE SET 
    enabled = $3,
    config = $4, 
    updated_at = $6 
RETURNING plugin_id, app_id, enabled, config, created_at, updated_at, commands_deployed_at
`

type UpsertPluginInstanceParams struct {
	AppID     string
	PluginID  string
	Enabled   bool
	Config    []byte
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) UpsertPluginInstance(ctx context.Context, arg UpsertPluginInstanceParams) (PluginInstance, error) {
	row := q.db.QueryRow(ctx, upsertPluginInstance,
		arg.AppID,
		arg.PluginID,
		arg.Enabled,
		arg.Config,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PluginInstance
	err := row.Scan(
		&i.PluginID,
		&i.AppID,
		&i.Enabled,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommandsDeployedAt,
	)
	return i, err
}
